/**
 * The Least Weasel Organisation
 * Copyright (C) 2004-2014 by Andrew Gillies
 */
package org.leastweasel.predict.domain;

import java.io.Serializable;

import javax.persistence.Convert;
import javax.persistence.Entity;
import javax.persistence.FetchType;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.ManyToOne;
import javax.persistence.Transient;
import javax.validation.constraints.NotNull;

import org.apache.commons.lang.builder.CompareToBuilder;
import org.apache.commons.lang.builder.EqualsBuilder;
import org.apache.commons.lang.builder.HashCodeBuilder;
import org.joda.time.DateTime;
import org.joda.time.format.DateTimeFormat;
import org.joda.time.format.DateTimeFormatter;

/**
 * A fixture, a match between two teams.
 */
@Entity
public class Fixture implements Serializable, Comparable<Fixture> {

	private static final long serialVersionUID = 1L;

	private Long id;

    private Team homeTeam;

    private Team awayTeam;

    private DateTime matchTime;

    private boolean knockoutFixture;
    
    private MatchResult result;

    /**
     * A short-cut to the competition to which this fixture belongs. Although we could navigate via
     * the phase and stage, it's more performant to go directly.
     */
    private Competition competition;
    
    /**
     * Get the fixture's unique id (generated by its data source). Will be null if not persistent.
     */
    @Id
    @GeneratedValue
    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    /**
     * Get the team playing at home in this fixture. Note that this value will be eagerly fetched.
     * 
     * @return the home team
     */
    @NotNull
    @ManyToOne(fetch = FetchType.EAGER)
    @JoinColumn(name = "home_team_id")
    public Team getHomeTeam() {
        return homeTeam;
    }

    /**
     * Set the team playing at home in this fixture.
     * 
     * @param homeTeam the home team
     */
    public void setHomeTeam(Team homeTeam) {
        this.homeTeam = homeTeam;
    }

    /**
     * Get the team playing away in this fixture. Note that this value will be eagerly fetched.
     * 
     * @return the away team
     */
    @NotNull
    @ManyToOne(fetch = FetchType.EAGER)
    @JoinColumn(name = "away_team_id")
    public Team getAwayTeam() {
        return awayTeam;
    }

    /**
     * Set the team playing away in this fixture.
     * 
     * @param awayTeam the away team
     */
    public void setAwayTeam(Team awayTeam) {
        this.awayTeam = awayTeam;
    }

    /**
     * Get the date and time at which the fixture kicks off.
     * 
     * @return the match's start time
     */
    @Convert(converter = DateTimeToDateConverter.class)
    public DateTime getMatchTime() {
		return matchTime;
	}

    /**
     * Set the date and time at which the fixture kicks off.
     * 
     * @param matchTime the match's start time
     */
    public void setMatchTime(DateTime matchTime) {
        this.matchTime = matchTime;
    }

	/**
     * Get the result of the fixture.
     * 
     * @return the match result
     */
    public MatchResult getResult() {
        return result;
    }

    /**
     * Does this match have a result. Yes unless either the <code>result</code> property is null or
     * if either of the scores in the <code>result</code> property is null.
     *
     * @return true if both home and away scores are defined
     */
    @Transient
    public boolean isFinished() {
        return result != null && result.isComplete();
    }

    /**
     * Set the result of the fixture.
     * 
     * @param result the match result
     */
    public void setResult(MatchResult result) {
        this.result = result;
    }

    /**
     * Directly get the competition in which this fixture is played, rather than via phase and
     * stage.
     * 
     * @return the competition in which the fixture is played
     */
    @NotNull
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "competition_id")
    public Competition getCompetition() {
        return competition;
    }

    /**
     * Set the competition in which this fixture is played.
     * 
     * @param competition the competition in which the fixture is played
     */
    public void setCompetition(Competition competition) {
        this.competition = competition;
    }

    /**
     * Is this fixture in a knock-out part of the competition.
     * 
     * @return true if this is a knock-out fixture
     */
    public boolean isKnockoutFixture() {
		return knockoutFixture;
	}

    /**
     * Set whether this fixture is in a knock-out part of the competition.
     * 
     * @param knockoutFixture true if this is a knock-out fixture
     */
	public void setKnockoutFixture(boolean knockoutFixture) {
		this.knockoutFixture = knockoutFixture;
	}

	/**
     * Equality operator.
     *
     * @param other the object we're comparing against
     * @return true if the objects are equal
     */
    @Override
    public boolean equals(Object other) {
        if (other == this) {
            return true;
        }

        if (other == null) {
            return false;
        }

        if (!this.getClass().equals(other.getClass())) {
            return false;
        }

        final Fixture fixture = (Fixture) other;

        return new EqualsBuilder().append(homeTeam, fixture.homeTeam)
                                  .append(awayTeam, fixture.awayTeam)
                                  .append(matchTime, fixture.matchTime)
                                  .append(result, fixture.result)
                                  .isEquals();
    }

    /**
     * Generate a hash code for this object.
     *
     * @return a hash code
     */
    @Override
    public int hashCode() {
        return new HashCodeBuilder().append(homeTeam)
                                    .append(awayTeam)
                                    .append(matchTime)
                                    .append(result)
                                    .toHashCode();
    }

    /**
     * Compare this object with another. This determines the order in which fixtures are sorted. We
     * want them sorted in order of increasing kick-off time. If they kick off at the same time we
     * then go by home team then away team. We don't use the result as there's no natural ordering.
     *
     * @param f the fixture to compare
     * @return -1 if this object is less than the supplied one, 1 if it's greater, 0 if the same
     */
    public int compareTo(Fixture f) {
        return new CompareToBuilder().append(matchTime, f.matchTime)
                                     .append(homeTeam, f.homeTeam)
                                     .append(awayTeam, f.awayTeam)
                                     .toComparison();
    }

    /**
     * Format the object as a String.
     *
     * @return the generated String
     */
    @Override
    public String toString() {
        StringBuilder buff = new StringBuilder();
        DateTimeFormatter fmt = DateTimeFormat.forPattern("dd MMM yyyy HH:mm");

        buff.append("ID = ");
        buff.append(id);
        buff.append(", ");
        buff.append(fmt.print(matchTime));
        buff.append(", ");
        buff.append(homeTeam);
        buff.append(" v ");
        buff.append(awayTeam);

        if (result != null) {
            buff.append(" (");
            buff.append(result);
            buff.append(")");
        }

        return buff.toString();
    }
}
