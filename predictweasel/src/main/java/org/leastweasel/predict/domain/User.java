/**
 * The Least Weasel Organisation
 * Copyright (C) 2004-2014 by Andrew Gillies
 */
package org.leastweasel.predict.domain;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.JoinTable;
import javax.persistence.ManyToMany;
import javax.persistence.Transient;
import javax.validation.constraints.NotNull;
import javax.validation.constraints.Size;

import org.apache.commons.lang.StringUtils;
import org.apache.commons.lang.builder.EqualsBuilder;
import org.apache.commons.lang.builder.HashCodeBuilder;
import org.apache.commons.lang.builder.ToStringBuilder;
import org.hibernate.validator.constraints.Email;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;

/**
 * A user of the site. A user has a user name, which is the same as their email address, used to
 * sign on to the site, a name by which they will be known to other users on the site, and a
 * password used during authentication. As passwords will be encrypted when stored it won't be
 * possible to send them to users, only offer them the chance to reset theirs. So the user can
 * provide a reminder that might prevent the need to reset it. The email address will be the one to
 * which all communications will be sent. Users can be active or inactive. Only active users can
 * use the site.
 * <p>
 * Users have a collection of roles which define the functionality available to the user. Each role
 * has an authority associated with it and it's actually the authorities that are used to define what
 * each user has access to. The difference between roles and authorities is highlighted by the fact
 * that all users are assigned a USER authority (indicating that the user is logged in) but not a
 * corresponding USER role.
 * <p>
 * <i>This class maps to the USER table in the database</i>.
 */
@Entity
public class User implements UserDetails {
	private static final long serialVersionUID = 1L;

	public static final int MIN_PASSWORD_LENGTH = 8;
	
	private static Logger logger = LoggerFactory.getLogger(User.class);

    /**
     * The value the user uses to sign in to the site.
     */
    private String username;

    /**
     * The user's unique id (generated by its data source). Will be null if not persistent.
     */
    private Long id;

    /**
     * The user's name as known to other users of the site.
     */
    private String name;

    /**
     * The password the user authenticates with. This will be encrypted before it is persisted.
     */
    private String password;

    /**
     * An aide-memoire for the user's password.
     */
    private String passwordReminder;

    /**
     * Is the user enabled.
     */
    private boolean enabled = true;

    /**
     * The collection of roles assigned to this user.
     */
    private Set<Role> roles = new HashSet<Role>();

    /**
     * The collection of authorities granted according to the user's roles.
     */
    private Collection<GrantedAuthority> authorities;

    /**
     * Default constructor. Creates an empty, non-persistent user.
     */
    public User() {
    }

    /**
     * Get the user's unique id.
     *
     * @return the user's unique id
     */
    @Id
    @GeneratedValue
    public Long getId() {
        return id;
    }

    /**
     * Set the user's unique id.
     *
     * @param id the user's unique id
     */
    public void setId(Long id) {
        this.id = id;
    }

    /**
     * Get the user's name.
     *
     * @return the user's name
     */
    @Column(unique = true)
    @NotNull
    @Size(min=1, max=30)
    public String getName() {
        return name;
    }

    /**
     * Set the user's name. Removes external whitespace and replaces blank strings with null.
     *
     * @param name the user's name
     */
    public void setName(String name) {
        this.name = StringUtils.trimToNull(name);
    }

    /**
     * Get the user's password. Note that this constraint's upper bound is determined by the
     * password encryption algorithm we're using as passwords are always encrypted before
     * being saved.
     *
     * @return the user's password
     */
    @NotNull
    @Size(min=MIN_PASSWORD_LENGTH)
    public String getPassword() {
        return password;
    }

    /**
     * Set the user's password. Removes external whitespace and replaces blank strings with null.
     *
     * @param password the user's password
     */
    public void setPassword(String password) {
        this.password = StringUtils.trimToNull(password);
    }

    /**
     * Get the user's password reminder.
     *
     * @return the user's password reminder
     */
    @Size(min=0, max=100)
    public String getPasswordReminder() {
        return passwordReminder;
    }

    /**
     * Set the user's password reminder.
     *
     * @param passwordReminder the user's password reminder
     */
    public void setPasswordReminder(String passwordReminder) {
        this.passwordReminder = passwordReminder;
    }

    /**
     * Get the user's user name. This is the same as the email address.
     *
     * @return the user's username
     */
    @Column(unique = true)
    @NotNull
    @Size(min=1, max=50)
    @Email
    public String getUsername() {
        return username;
    }

    /**
     * Set the user's email address. Removes external whitespace and replaces blank strings with
     * null.
     *
     * @param username the user's username
     */
    public void setUsername(String username) {
        this.username = StringUtils.trimToNull(username);
    }

    /**
     * Get the user's email address.
     *
     * @return the user's email address
     */
    @Transient
    public String getEmailAddress() {
        return username;
    }

    /**
     * Get the list of roles assigned to the user. The roles define, via their respective granted
     * authorities, which areas of the site the user has access to and, occasionally, which domain
     * objects the user can view or modify. A user always has at least the USER granted authority.
     *
     * @return the list of roles assigned to the user
     */
    @ManyToMany
    @JoinTable(name = "user_role", joinColumns = { @JoinColumn(name = "user_id") },
               inverseJoinColumns = { @JoinColumn(name = "role_id") })
    public Set<Role> getRoles() {
        return roles;
    }

    /**
     * Set the list of roles to be assigned to the user. The granted authority from each role is
     * also stored.
     *
     * @param roles the roles to be assigned
     */
    public void setRoles(Set<Role> roles) {
        this.roles = roles;

        if (logger.isDebugEnabled()) {
			logger.debug("Adding {} roles to user ID: {}", roles.size(), getId());
		}
        
        // We automatically assign a 'User' authority to all users.
        List<GrantedAuthority> list = new ArrayList<GrantedAuthority>();
        // list.add(new SimpleGrantedAuthority(Role.USER_AUTHORITY));

        for (Role role : roles) {
            list.add(new SimpleGrantedAuthority(role.getGrantedAuthority()));
        }

        authorities = list;
    }

    /**
     * Add a role to this user. The role will not be added if it already exists.
     *
     * @param role the role to be added
     */
    public void addRole(Role role) {
        if (getRoles().contains(role)) {
            if (logger.isDebugEnabled()) {
                logger.debug("Role ({}) already exists for user ({})", role.getGrantedAuthority(), id);
            }
        } else {
            if (logger.isDebugEnabled()) {
                logger.debug("Adding a role ({}) to user ({})", role.getGrantedAuthority(), id);
            }

            getRoles().add(role);

            // Do this so that the granted authorities are properly set.
            setRoles(getRoles());
        }
    }

    /**
     * Remove the given role. Does nothing if the user does not have the role.
     *
     * @param role the role to remove
     */
    public void removeRole(Role role) {
        if (!getRoles().contains(role)) {
            return;
        }

        if (logger.isDebugEnabled()) {
            logger.debug("Removing a role ({}) from user ()", role.getGrantedAuthority(), id);
        }

        getRoles().remove(role);

        // Do this so that the granted authorities are properly set.
        setRoles(getRoles());
    }

    /**
     * Removes all the user's roles.
     */
    public void removeAllRoles() {
        roles.clear();

        // Update the authorities.
        setRoles(roles);
    }

    /**
     * Get the authorities granted to this user.
     *
     * @return the granted authorities
     */
    @Transient
    public Collection<GrantedAuthority> getAuthorities() {
        return authorities;
    }

    /**
     * Does this user have this authority.
     *
     * @param grantedAuthority the authority to check
     * @return true if the user has this authority, otherwise false
     */
    public boolean hasAuthority(String grantedAuthority) {
        if (authorities == null) {
            return false;
        }

        for (GrantedAuthority g : authorities) {
            if (g.getAuthority().equals(grantedAuthority)) {
                return true;
            }
        }

        return false;
    }

    /**
     * Is the user a super administrator.
     *
     * @return true if the user is a super administrator
    @Transient
    public boolean isSuperAdmin() {
        return hasAuthority(Role.SUPER_USER_AUTHORITY);
    }
     */

    /**
     * Is this a guest user ? Guest users can play games they're subscribed to but can't subscribe
     * themselves, nor can they modify their user details.
     *
     * @return true if this is a guest user
    @Transient
    public boolean isGuest() {
        return hasAuthority(Role.GUEST_AUTHORITY);
    }
     */

    /**
     * Set whether the user is enabled.
     *
     * @param enabled true if the user is to be enabled
     */
    public void setEnabled(boolean enabled) {
        this.enabled = enabled;
    }

    /**
     * Is this user enabled. Disabled users can't use the application.
     *
     * @return true if the user is enabled
     */
    @Transient
    public boolean isEnabled() {
        return enabled;
    }

    /**
     * Is this user enabled. Disabled users can't use the application.
     *
     * @return true if the user is enabled
     */
    @NotNull
    public boolean getEnabled() {
        return enabled;
    }

    /**
     * Indicates whether the user's account has expired. An expired account cannot be authenticated.
     *
     * @return always returns true (the account has not expired)
     */
    @Transient
    public boolean isAccountNonExpired() {
        return true;
    }

    /**
     * Indicates whether the user is locked or unlocked. A locked user cannot be authenticated.
     *
     * @return always returns true (the account is not locked)
     */
    @Transient
    public boolean isAccountNonLocked() {
        return true;
    }

    /**
     * Indicates whether the user's credentials (password) has expired. Expired credentials prevent
     * authentication.
     *
     * @return always returns true (the account has not expired)
     */
    @Transient
    public boolean isCredentialsNonExpired() {
        return true;
    }

    /**
     * Implementation of the equals comparison on the basis of equality of the business key values.
     *
     * @param other the object to compare
     * @return boolean true if the business keys are equal
     */
    @Override
    public boolean equals(Object other) {
        if (other == this) {
            return true;
        }

        if (other == null) {
            return false;
        }

        if (!this.getClass().equals(other.getClass())) {
            return false;
        }

        User user = (User) other;

        return new EqualsBuilder().append(name, user.name)
                                  .append(username, user.username)
                                  .append(passwordReminder, user.passwordReminder)
                                  .append(enabled, user.enabled)
                                  .append(roles, user.roles)
                                  .isEquals();
    }

    /**
     * Generate a hash code for this object.
     *
     * @return a hash code
     */
    @Override
    public int hashCode() {
        return new HashCodeBuilder().append(name)
                                    .append(username)
                                    .append(passwordReminder)
                                    .append(enabled)
                                    .append(roles)
                                    .hashCode();
    }

    /**
     * Format the object as a String.
     *
     * @return the generated String
     */
    @Override
    public String toString() {
        return new ToStringBuilder(this).append("User ID", id)
                                    .append("Name", name)
                                    .append("Password", password)
                                    .append("Password reminder", passwordReminder)
                                    .append("Email address", username)
                                    .append("Enabled", enabled)
                                    .append("Roles", roles)
                                    .toString();
    }
}
